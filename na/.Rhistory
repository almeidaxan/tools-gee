colnames(tmp) <- python.get("colNames")
# Exclui dados saturados, caso existam
filterWhich <- which(rowSums(tmp[, 2:ncol(tmp)] == 2) > 0)
if (length(filterWhich) > 0) {
tmp <- tmp[-filterWhich, ]
}
# Se os dados existem, cria coluna com nome do satelite e cresce o df final
if(tmp$date[1] %>% is.na %>% not) {
tmp$sat <- sat[i]
df <- rbind(df, tmp)
}
python.assign("aux", NULL)
python.assign("serie", NULL)
python.assign("values", NULL)
python.assign("numCol", NULL)
python.assign("colNames", NULL)
cat(paste(sat[i], "baixado\n"))
}
plot(df$ndmi, type = "l")
plot(df$ndvi, type = "l")
plot(df$evi, type = "l")
plot(df$evi2, type = "l")
head(df)
intToBits(8)
intToBits(66)
intToBits(66)[1]
intToBits(66)[2]
intToBits(66)[2] %>% as.numeric
intToBits(66)[2] == 1
intToBits(66)[2] == 0
if(intToBits(66)[2]) print "x"
if(intToBits(66)[2]) print("x")
summary(df$date)
intToBits(df$pixel_qa) %>% dim
intToBits(df$pixel_qa) %>% length
dim(4832)
dim(df)
4832/151
tmp <- intToBits(df$pixel_qa)
tmp <- intToBits(df$pixel_qa) %>% as.matrix(nrow = nrow(df))
dim(tmp)
tmp <- intToBits(df$pixel_qa) %>% as.matrix(nrow = nrow(df), ncol = ncol(df))
dim(tmp)
tmp <- intToBits(df$pixel_qa) %>% matrix(nrow = nrow(df), ncol = ncol(df))
tmp <- intToBits(df$pixel_qa) %>% matrix(nrow = nrow(df))
dim(tmp)
head(tmp)
df$cloudbit <- tmp[, 2]
head(df)
df$cloudbit %>% table
dim(df)
df$ndvi %>% plot(type = "l")
df$cloudbit %>% as.numeric %>% table
df$cloudbit <- tmp[, 2] %>% as.numeric
p_load(data.table)
setDT(df)
df <- df[cloudbit == 1,]
dim(df)
head(df)
plot(df$ndvi)
plot(df$ndvi, type = "l")
plot(df$ndmi, type = "l")
plot(df$evi, type = "l")
plot(df$evi2, type = "l")
intToBits(352)
# Call Python download script for each selected satellite
df <- NULL
for(i in 1:length(sat)) {
# Define qual satelite vai ser baixado
python.assign("satChoice", sat[i])
# Executa o script to Python
python.load(file.path("gee-px-ls.py"))
# Recebe o output do Python; se dados nao estiverem disponiveis, recebe NA
if (is.null(unlist(python.get("serie")))) {
serie <- NA
} else {
serie <- unlist(python.get("serie"))
}
# Transforma dados do Python em um df
tmp <- data.frame(matrix(serie,
ncol = python.get("numCol"),
byrow = T))
# Formatacao das classes dos dados e colunas do df
tmp[, 1] <- as.Date(tmp[, 1], format = "%Y_%m_%d")
tmp[, 2:ncol(tmp)] <- apply(tmp[, 2:ncol(tmp)],
MARGIN = 2,
as.numeric)
colnames(tmp) <- python.get("colNames")
# Exclui dados saturados, caso existam
filterWhich <- which(rowSums(tmp[, 2:ncol(tmp)] == 2) > 0)
if (length(filterWhich) > 0) {
tmp <- tmp[-filterWhich, ]
}
# Se os dados existem, cria coluna com nome do satelite e cresce o df final
if(tmp$date[1] %>% is.na %>% not) {
tmp$sat <- sat[i]
df <- rbind(df, tmp)
}
python.assign("aux", NULL)
python.assign("serie", NULL)
python.assign("values", NULL)
python.assign("numCol", NULL)
python.assign("colNames", NULL)
cat(paste(sat[i], "baixado\n"))
}
dim9df
dim(df)
df2 <- df
tmp <- intToBits(df2$pixel_qa) %>% matrix(nrow = nrow(df2))
tmp
head(tmp)
df2$cloudbit <- tmp[, 2] %>% as.numeric
head(df2)
setDT(df2)
df2 <- df2[cloudbit == 1,]
head(df2)
intToBits(352)
tmp <- intToBits(df2$pixel_qa) %>% matrix(nrow = nrow(df2), byrow = T)
tmp
df2$cloudbit <- tmp[, 2] %>% as.numeric
df2$cloudbit %>% table
df2 <- df
tmp <- intToBits(df2$pixel_qa) %>% matrix(nrow = nrow(df2), byrow = T)
df2$cloudbit <- tmp[, 2] %>% as.numeric
df2$cloudbit %>% table
setDT(df2)
df2 <- df2[cloudbit == 1,]
head(df2)
intToBits(322)
plot(df2$ndvi, type = "l")
plot(df2$ndmi, type = "l")
plot(df2$evi, type = "l")
plot(df2$evi2, type = "l")
df2$confBit <- 0
df2 <- df
tmp <- intToBits(df2$pixel_qa) %>% matrix(nrow = nrow(df2), byrow = T)
head(tmp)
tmp <- intToBits(df2$pixel_qa) %>% matrix(nrow = nrow(df2), byrow = T) %>% as.numeric
tmp
dim(tmp)
tmp <- intToBits(df2$pixel_qa) %>% as.numeric %>% matrix(nrow = nrow(df2), byrow = T)
tmp
df2 <- df2[tmp[, 2] == 1,]
dim(df2)
df2$confBit <- tmp[, 7] + tmp[, 8] * 2
tmp <- intToBits(df2$pixel_qa) %>% as.numeric %>% matrix(nrow = nrow(df2), byrow = T)
df2$clearBit <- tmp[, 2]
df2$confBit <- tmp[, 7] + tmp[, 8] * 2
head(df2)
dim(df2)
df2 <- df
tmp <- intToBits(df2$pixel_qa) %>% as.numeric %>% matrix(nrow = nrow(df2), byrow = T)
df2$clearBit <- tmp[, 2]
df2$confBit <- tmp[, 7] + tmp[, 8] * 2
dim(df2)
head(df2)
df2$confBit %>% table
intToBits(1)
intToBits(0)
intToBits(1)
intToBits(2)
intToBits(66)
tmp
df
df2
df2 <- df2[clearBit == 1, ]
setDT(df2)
df2 <- df2[clearBit == 1, ]
dim9df2
df2()
df2 %>% dim
df2$confBit %>% table
head(df)
head(df2)
df2 <- df2[, -c("pixel_qa", "clearBit")]
head(df2)
df2$confBit %>% table
which(df2$confBit == 2)
df2[30]
df2
df2[sat == "LT04/C01/T1_SR", sat := "LSR4"]
table(df2$sat)
df2[sat == "LC08/C01/T1_SR", sat := "LSR8"]
table(df2$sat)
# Call Python download script for each selected satellite
df <- NULL
for(i in 1:length(sat)) {
# Define qual satelite vai ser baixado
python.assign("satChoice", sat[i])
# Executa o script to Python
python.load(file.path("gee-px-ls.py"))
# Recebe o output do Python; se dados nao estiverem disponiveis, recebe NA
if (is.null(unlist(python.get("serie")))) {
serie <- NA
} else {
serie <- unlist(python.get("serie"))
}
# Transforma dados do Python em um df
tmp <- data.frame(matrix(serie,
ncol = python.get("numCol"),
byrow = T))
# Formatacao das classes dos dados e colunas do df
tmp[, 1] <- as.Date(tmp[, 1], format = "%Y_%m_%d")
tmp[, 2:ncol(tmp)] <- apply(tmp[, 2:ncol(tmp)],
MARGIN = 2,
as.numeric)
colnames(tmp) <- python.get("colNames")
# Exclui dados saturados, caso existam
filterWhich <- which(rowSums(tmp[, 2:ncol(tmp)] == 2) > 0)
if (length(filterWhich) > 0) {
tmp <- tmp[-filterWhich, ]
}
# Se os dados existem, cria coluna com nome do satelite e cresce o df final
if(tmp$date[1] %>% is.na %>% not) {
tmp$sat <- sat[i]
df <- rbind(df, tmp)
}
python.assign("aux", NULL)
python.assign("serie", NULL)
python.assign("values", NULL)
python.assign("numCol", NULL)
python.assign("colNames", NULL)
cat(paste(sat[i], "baixado\n"))
}
# Satelites para baixar
sat <- c("LT04/C01/T1_SR", "LT05/C01/T1_SR", "LE07/C01/T1_SR", "LC08/C01/T1_SR")
# Call Python download script for each selected satellite
df <- NULL
for(i in 1:length(sat)) {
# Define qual satelite vai ser baixado
python.assign("satChoice", sat[i])
# Executa o script to Python
python.load(file.path("gee-px-ls.py"))
# Recebe o output do Python; se dados nao estiverem disponiveis, recebe NA
if (is.null(unlist(python.get("serie")))) {
serie <- NA
} else {
serie <- unlist(python.get("serie"))
}
# Transforma dados do Python em um df
tmp <- data.frame(matrix(serie,
ncol = python.get("numCol"),
byrow = T))
# Formatacao das classes dos dados e colunas do df
tmp[, 1] <- as.Date(tmp[, 1], format = "%Y_%m_%d")
tmp[, 2:ncol(tmp)] <- apply(tmp[, 2:ncol(tmp)],
MARGIN = 2,
as.numeric)
colnames(tmp) <- python.get("colNames")
# Exclui dados saturados, caso existam
filterWhich <- which(rowSums(tmp[, 2:ncol(tmp)] == 2) > 0)
if (length(filterWhich) > 0) {
tmp <- tmp[-filterWhich, ]
}
# Se os dados existem, cria coluna com nome do satelite e cresce o df final
if(tmp$date[1] %>% is.na %>% not) {
tmp$sat <- sat[i]
df <- rbind(df, tmp)
}
python.assign("aux", NULL)
python.assign("serie", NULL)
python.assign("values", NULL)
python.assign("numCol", NULL)
python.assign("colNames", NULL)
cat(paste(sat[i], "baixado\n"))
}
tmp <- intToBits(df$pixel_qa) %>% as.numeric %>% matrix(nrow = nrow(df), byrow = T)
df$clearBit <- tmp[, 2]
df$confBit <- tmp[, 7] + tmp[, 8] * 2
setDT(df)
df <- df[clearBit == 1, ]
df <- df[, -c("pixel_qa", "clearBit")]
df[sat == "LT04/C01/T1_SR", sat := "LSR4"]
df[sat == "LT05/C01/T1_SR", sat := "LSR5"]
df[sat == "LE07/C01/T1_SR", sat := "LSR7"]
df[sat == "LC08/C01/T1_SR", sat := "LSR8"]
dim(df)
df
plot(df$evi, type = "l")
plot(df$evi2, type = "l")
plot(df$ndvi, type = "l")
plot(df$ndmi, type = "l")
df$confBit %>% table
require(pacman)
p_load("RPushbullet")
require(jsonlite)
pbGetDevices()
fromJSON(pbGetDevices())$devices[,c("iden", "nickname")]
fromJSON
p_load("RPushbullet")
fromJSON(pbGetDevices())$devices[,c("iden", "nickname")]
require(pacman)
p_load("jsonlite")
p_load("RPushbullet")
pbGetDevices()
fromJSON(pbGetDevices())
pbGetDevices()
pbGetDevices(apikey = "o.EJM2VsELra75Dda2QWVjeVE7wJurqyJL")
fromJSON(pbGetDevices(apikey = "o.EJM2VsELra75Dda2QWVjeVE7wJurqyJL"))
pbGetDevices(apikey = "o.EJM2VsELra75Dda2QWVjeVE7wJurqyJL")
pbGetDevices(apikey = "EJM2VsELra75Dda2QWVjeVE7wJurqyJL")
pbGetDevices(apikey = "o.EJM2VsELra75Dda2QWVjeVE7wJurqyJL")
pbGetDevices(apikey = "o.EJM2VsELra75Dda2QWVjeVE7wJurqyJL") %>% print
p_load(magrittr)
p_load(magrittr)
pbGetDevices(apikey = "o.EJM2VsELra75Dda2QWVjeVE7wJurqyJL") %>% print
pbGetDevices(apikey = "o.EJM2VsELra75Dda2QWVjeVE7wJurqyJL") %>% summary
fromJSON(pbGetDevices(apikey = "o.EJM2VsELra75Dda2QWVjeVE7wJurqyJL"))
fromJSON(pbGetDevices(apikey = "o.EJM2VsELra75Dda2QWVjeVE7wJurqyJL") %>% print)
pbGetDevices(apikey = "o.EJM2VsELra75Dda2QWVjeVE7wJurqyJL")$devices
pbGetDevices()$devices[, c("iden", "nickname")]
fromJSON(pbGetDevices()$devices[, c("iden", "nickname")])
require(pacman)
p_load(jsonlite)
p_load(magrittr)
p_load(RPushbullet)
pbGetDevices()$devices
pbPost("note", "Title of note", "Body of message")
pbPost("pinto", "mucho", "trator")
pbPost("note", "pinto", "mucho")
pbGetDevices()$devices
pbGetDevices()$devices[, c("iden", "nickname")])
pbGetDevices()$devices
pbGetDevices()$devices
(pbGetDevices()$devices)[, c("iden", "nickname")])
devs
devs <- pbGetDevices()$devices
devs
pbGetDevices()$devices[, c("iden", "nickname")]
pbGetDevices()$devices[, c("iden", "nickname")]
pbPost("note", "pinto", "mucho")
pbPost("note", "oi", "coco seco")
pbPost("note", "feca", "lito")
pbPost("note", "feca", "lito")
pbPost("note", "eeee", "lito")
pbGetDevices()$devices[, c("iden", "nickname")]
p_load(telegram)
Sys.getenv()
require(pacman)
p_load(magrittr)
p_load(telegram)
bot_token
bot_token()
telegram::bot_token("RBot")
bot <- TGBot$new(token = bot_token('RBot'))
bot
bot$getMe()
bot$getUpdates()
bot$set_default_chat_id(353968648)
require(pacman)
p_load(magrittr)
p_load(telegram)
Sys.getenv()
## Create the bot object
bot <- TGBot$new(token = bot_token('RBot'))
bot$getUpdates()
user_id('me')
bot$set_default_chat_id(user_id('me'))
bot$sendMessage('This is text')
bot$sendMessage('This is text')
system("screencapture ~/Downloads/teste.jpg")
bot$sendPhoto("~/Downloads/teste.jpg", caption = "This is my awesome graph")
require(pacman)
p_load(data.table)
p_load(magrittr)
p_load(rPython)
p_load(telegram)
# Configurando o bot do Telegram
bot <- TGBot$new(token = bot_token("RBot"))
bot$set_default_chat_id(user_id("me"))
bot
system("screencapture ~/Downloads/teste.jpg")
Sys.sleep(5)
bot$sendPhoto("~/Downloads/teste.jpg", caption = "Prontininho!")
system("screencapture ~/Downloads/teste.jpg")
# Satelites para baixar
sat <- c("LT04/C01/T1_SR", "LT05/C01/T1_SR", "LE07/C01/T1_SR", "LC08/C01/T1_SR")
# CSV com as coordenadas dos pontos para baixar
dfCoords <- read.csv("coords-amazonia.csv")
# Arquivo que sera salvo
arquivo <- "/Users/almeida/Dropbox/Ná/Unicamp/Programas/data/rdata/amazonia.rds"
if(file.exists(arquivo)) {
serieList <- readRDS(arquivo)
startJ <- (serieList %>% length) + 1
} else {
serieList <- list()
startJ <- 1
}
startJ
pb <- txtProgressBar(min = 0, max = nrow(dfCoords), style = 3)
for(j in startJ:nrow(dfCoords)) {
# Ponto para ser baixado
lat <- dfCoords$lat[j]
lng <- dfCoords$long[j]
python.assign("coords", c(lng, lat)) # <- deve estar na ordem (lng, lat)
# Chama o script em Python para download das series
df <- NULL
for(i in 1:length(sat)) {
# Define qual satelite vai ser baixado
python.assign("satChoice", sat[i])
# Executa o script do Python
python.load(file.path("gee-px-ls.py"))
# Recebe o output do Python; se dados nao estiverem disponiveis, recebe NULL
if (is.null(unlist(python.get("serie")))) {
serie <- NULL
} else {
serie <- unlist(python.get("serie"))
}
if(serie %>% is.null %>% not) {
# Transforma dados do Python em um df
# Remove
tmp <- matrix(serie,
ncol = python.get("numCol"),
byrow = T) %>% as.data.frame()
isRowNA <- apply(tmp, MARGIN = 1, FUN = function(x) {
(x == "NA") %>% sum
})
tmp <- tmp[isRowNA == 0, ]
# Caso todas as linhas sejam NA, nao roda o resto do codigo
if(nrow(tmp) > 0) {
tmp[, 1] %<>% as.character
tmp[, 2:python.get("numCol")] %<>% lapply(FUN = function(x) {
x %>% as.character %>% as.numeric %>% round(4)
})
tmp %<>% as.data.frame()
# Formatacao das classes dos dados e colunas do df
tmp[, 1] <- as.Date(tmp[, 1], format = "%Y_%m_%d")
tmp[, 2:ncol(tmp)] <- apply(tmp[, 2:ncol(tmp)],
MARGIN = 2,
as.numeric)
colnames(tmp) <- python.get("colNames")
# Exclui dados saturados, caso existam
filterWhich <- which(rowSums(tmp[, 2:ncol(tmp)] == 2) > 0)
if (length(filterWhich) > 0) {
tmp <- tmp[-filterWhich, ]
}
# Se os dados existem, cria coluna com nome do satelite e cresce o df final
if(tmp$date[1] %>% is.na %>% not) {
tmp$sat <- sat[i]
df <- rbind(df, tmp)
}
}
}
python.assign("aux", NULL)
python.assign("serie", NULL)
python.assign("values", NULL)
python.assign("numCol", NULL)
python.assign("colNames", NULL)
# cat(paste(sat[i], "baixado\n"))
}
if(df %>% is.null %>% not) {
tmp <- intToBits(df$pixel_qa) %>% as.numeric %>% matrix(nrow = nrow(df), byrow = T)
df$clearBit <- tmp[, 2]
df$confBit <- tmp[, 7] + tmp[, 8] * 2
setDT(df)
df <- df[clearBit == 1, ]
df <- df[, -c("pixel_qa", "clearBit")]
df[sat == "LT04/C01/T1_SR", sat := "LSR4"]
df[sat == "LT05/C01/T1_SR", sat := "LSR5"]
df[sat == "LE07/C01/T1_SR", sat := "LSR7"]
df[sat == "LC08/C01/T1_SR", sat := "LSR8"]
setkey(df, "date")
}
serieList[[j]] <- df
saveRDS(serieList, arquivo)
setTxtProgressBar(pb, j)
}
close(pb)
system("screencapture ~/Downloads/teste.jpg")
Sys.sleep(5)
bot$sendPhoto("~/Downloads/teste.jpg", caption = "Prontininho!")
serieList %>% len
serieList %>% length()
serieList[[1]]
serieList[[2]]
for(i in 1:1000){
1+2
}
system("screencapture ~/Downloads/teste.jpg")
for(i in 1:1000){
1+2
}
system("screencapture ~/Downloads/teste.jpg")
Sys.sleep(5)
bot$sendPhoto("~/Downloads/teste.jpg", caption = "Prontininho!")
for(i in 1:1000){
1+2
}
system("screencapture ~/Downloads/teste.jpg")
Sys.sleep(5)
bot$sendPhoto("~/Downloads/teste.jpg", caption = "Prontininho!")
serieList <- readRDS(arquivo)
serieList %>% length()
serieList[[1004]]
serieList[[1000]]
plot(serieList[[1000]]$evi2, type="l")
plot(serieList[[1004]]$evi2, type="l")
plot(serieList[[500]]$evi2, type="l")
plot(serieList[[400]]$evi2, type="l")
plot(serieList[[300]]$evi2, type="l")
plot(serieList[[200]]$evi2, type="l")
plot(serieList[[100]]$evi2, type="l")
plot(serieList[[50]]$evi2, type="l")
plot(serieList[[1]]$evi2, type="l")
plot(serieList[[2]]$evi2, type="l")
plot(serieList[[2]]$evi, type="l")
plot(serieList[[1]]$evi, type="l")
plot(serieList[[1]]$ndvi, type="l")
plot(serieList[[1000]]$ndvi, type="l")
plot(serieList[[1000]]$evi, type="l")
plot(serieList[[1000]]$evi2, type="l")
plot(serieList[[1000]]$ndmi, type="l")
